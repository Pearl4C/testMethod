# Content
- [一 软件测试](#一-软件测试)
    - [软件测试定义](#1软件测试定义)
    - [软件测试的重要性](#2软件测试的重要性)
    - [软件测试流程](#3软件测试流程)
- [二 测试环境](#二-测试环境)
    - [什么是测试环境](#1什么是测试环境)
    - [怎样搭建测试环境](#2怎样搭建测试环境)
    - [软件环境的分类](#3软件环境的分类)
- [三 测试计划](#三-测试计划)
    - [为什么要有测试计划](#1为什么要有测试计划)
    - [如何编写测试计划](#2如何编写测试计划)
- [四 测试用例](#四-测试用例)
    - [什么是测试用例](#1什么是测试用例)
    - [为什么要写测试用例](#2为什么要写测试用例)
    - [什么时候写测试用例](#3什么时候写测试用例)
    - [测试用例设计方法](#4测试用例设计方法)
    - [测试用例模板](#5测试用例模板)
    - [测试用例管理和维护](#6测试用例管理和维护)
- [五 软件测试分类](#五-软件测试分类)
    - [黑盒测试和白盒测试](#1黑盒测试和白盒测试)
    - [静态测试和动态测试](#2静态测试和动态测试)
    - [单元测试、集成测试、系统测试和验收测试](#3单元测试集成测试系统测试和验收测试)
    - [功能测试和性能测试](#4功能测试和性能测试)
    - [回归测试、冒烟测试、随机测试](#5回归测试冒烟测试随机测试)
    - [不同测试分类之间的关系](#6不同测试分类之间的关系)
- [六 软件测试的一些基本原则](#六-软件测试的一些基本原则)
    - [Zero Bug与Good Enough](#1zero-bug与good-enough)
    - [不要试图穷举测试](#2不要试图穷举测试)
    - [软件测试要尽早执行](#3软件测试要尽早执行)
    - [软件测试应该追溯需求](#4软件测试应该追溯需求)
    - [缺陷的二八定理](#5缺陷的二八定理)
    - [缺陷具有免疫性](#6缺陷具有免疫性)
- [七 软件测试技术](#七-软件测试技术)
    - [等价类技术](#1等价类技术)
    - [边界值技术](#2边界值技术)
    - [因果图法](#3因果图法)
    - [流程图法](#4流程图法)
- [八 缺陷管理](#八-缺陷管理)
    - [Bug的分类](#1bug的分类)
    - [缺陷报告](#2缺陷报告)
    - [Bug的处理流程](#3bug的处理流程)
- [九 测试管理](#九-测试管理)
    - [软件的生命周期](#1软件的生命周期)
    - [软件测试评估](#2软件测试评估)
    - [软件测试报告](#3软件测试报告)
- [参考文献](#参考文献)

# 一 软件测试

## 1、软件测试定义
标准定义：使用人工或自动手段，来运行或测试某个系统的过程。其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。

## 2、软件测试的重要性
软件测试的目的是确保软件的质量、确认软件以正确的方式做了你所期望的事情，它的工作主要是发现软件的错误、验证软件是否满足需求和系统定义文档所规定的技术要求、为软件质量模型的建立提供依据。

软件的测试不仅是要确保软件的质量，还要给开发人员提供信息，以方便其为风险评估做相应的准备，它要贯穿在整个软件开发的过程中，保证整个软件开发的过程是高质量的。

以往的经验教训告诉我们，软件测试在整个软件开发的过程中是不可或缺的。如果能够及早的发现爱国者导弹防御系统的缺陷，就不会有28个灵魂的悲歌；如果能够早日发挥软件测试的功效，也许“千年虫”将被扼杀于摇篮之中，那么数百亿美元的损失费用将能够促进又一个跨世纪的综合国力的提升；如果能在最开始的时候发现狮子王程序的漏洞，那么也不会给孩子们的童年带来不快乐的记忆和阴影。正是这些小的错误酿成的巨大反响，使我们不得不重视软件测试，正确的认识到软件测试在整个软件开发过程中的重要性。

## 3、软件测试流程  
软件测试的基本流程：  
- 测试需求分析阶段：阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议。

- 测试计划阶段：主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围（来自需求文档），进度安排，人力物力的分配，整体测试策略的制定。风险评估与规避措施有一个制定。

- 测试设计阶段：主要是编写测试用例，会参考需求文档（原型图），概要设计，详细设计等文档，用例编写完成之后会进行评审。

- 测试执行阶段：搭建环境，执行冒烟测试（预测试），再进入正式测试，bug管理直到测试结束。

- 测试评估阶段：出测试报告，确认是否可以上线。


# 二 测试环境

## 1、什么是测试环境
这里的测试环境特指软件测试环境，就是软件运行的平台，即硬件、软件和网络的集合。

## 2、怎样搭建测试环境
搭建测试环境有如下几个要点：  
- 真实（尽量模拟用户的真实使用环境）  
- 干净（测试环境中尽量不要安装其他与被测软件无关的软件）  
- 无毒（测试环境没有中毒）  
- 独立（测试环境和开发环境独立）

## 3、软件环境的分类
软件环境主要包括以下三种：  
- 软件开发环境：软件在开发过程中使用的环境，一般包括Java、VB、VC等一些开发工具。
- 软件测试环境：软件在测试过程中使用的环境。 
- 软件生产运行环境：最终用户使用的环境。  
需要注意的是，软件测试环境要与软件生产运行环境保持一致，要从开发环境中独立出来。


# 三 测试计划

## 1、为什么要有测试计划
编写测试计划的几点好处：  
- 测试计划是高效测试的基础；  
- 充分的准备工作可以有效克服测试的盲目性；  
- 测试计划可以缩短测试周期，提高测试效率，并起到测试文档和开发文档互查的作用；  
- 测试计划提供一个与测试团队、开发团队和管理部门互相交流的机会；  
- 测试计划定义工作范围，并制定由谁来负责此工作。

## 2、如何编写测试计划
编写测试计划时应注意以下几点：
- 增强测试计划的实用性
- 坚持“5W1H”规则，明确内容与过程
    - 明确测试的范围和内容（What）
    - 测试的目的（Why）
    - 确定测试的开始和结束日期（When）
    - 给出测试文档和软件的存放位置（Where）
    - 测试人员的分配（Who）
    - 说明测试的方法和工具（How）
- 采用评审和更新机制，保证测试计划满足实际需求
- 分别创建测试计划与测试策略


# 四 测试用例

## 1、什么是测试用例
测试用例指的是在测试执行之前设计的一套详细的测试方案，包括测试环境、测试步骤、测试数据和预期结果。

## 2、为什么要写测试用例
编写测试用例有如下好处：
- 便于团队交流
- 便于重复测试
- 便于跟踪统计
- 便于用户自测

## 3、什么时候写测试用例  
测试用例要尽早编写，我们通常会在测试设计阶段来写用例，即《需求规格说明书》和《测试计划》都已完成之后。

## 4、测试用例设计方法
常见的测试用例设计方法有如下几种：
- 等价类划分法：把所有输入的数据划分成若干部分（子集），然后从每部分中选择有代表性的少数部分数据作为测试数据，代表性数据等同于子集中其它数据。  
- 边界值分析法：由于边界值容易产生错误，是在等价类划分法上补充的方法。  
- 错误推测法：根据经验和直觉推测程序可能出现错误的地方。  
- 因果图法：根据输入条件的各种组合,以及相互制约关系的一种方法。  
- 正交实验法：在各因素互相独立的情况下，设计出一种特殊的表格，找出能以少数替代全面的测试用例。  
- 场景法：基本流和备选流，一般基本流为正常的测试，测试结果为成功的测试，备选流为异常的情况测试。
以上有部分的方法在第七章有详细讲解。

## 5、测试用例模板
 
不同的测试用例书写模板在风格和样式会有所区别，但本质上都是一样的，都包括了测试用例的基本要素：测试环境、操作步骤、输入数据和期望结果。  
实际工作中，可以根据实际情况灵活去修改其样式和内容，不用拘泥于固定的格式。以下测试用例的模板可作为参考。  
![测试用例模板](media/image21.png)

## 6、测试用例管理和维护  
软件产品的版本是随着软件的升级而不断变化的，而每一次版本的变化都会对测试用例集产生影响，所以测试用例集也需要不断地变更和维护，使之与产品的变化保持一致。  

以下原因可能导致测试用例变更：  
（1）软件需求变更：软件需求变更可能导致软件功能的增加、删除、修改等变化，应遵循需求变更控制管理方法，同样变更的测试用例也需要执行变更管理流程。  
（2）测试需求的遗漏和误解：由于测试需求分析不到位，可能导致测试需求遗漏或者误解，相应的测试用例也要进行变更。特别是对于软件隐性需求，在测试需求分析阶段容易遗漏，而在测试执行过程中被发现，这时需要补充测试用例。  
（3）测试用例遗漏：在测试过程中，发现测试用例未覆盖全部需求，需要补充相应的测试用例。  
（4）软件发布后，用户反馈的缺陷：表明测试不全面，存在尚未发现的缺陷，需要补充或者修改测试用例。  

对于提供软件服务的产品，其多个版本常常共存，而对应的测试用例也是共存的，而且测试用例需要专人定期维护，并遵循以下原则：  
（1）及时删除过时的测试用例  
需求变更可能导致原有部分测试用例不再适合新的需求要求。例如，删除了某个功能，那么针对该功能的测试用例也不再需要。所以随着需求的每一次变更，都要删除那些不再使用的测试用例。  
（2）及时删除冗余的测试用例  
在设计测试用例时，可能存在两个或者多个用例测试相同内容，降低回归测试效率，所以要定期整理测试用例集，及时删除冗余的测试用例。  
（3）增加新的测试用例  
由于需求变更、用例遗漏或者版本发布后发现缺陷等原因，原有的测试用例集没有完全覆盖软件需求，需要增加新的测试用例。  
（4）改进测试用例  
随着开发工作进行，测试用例不断增加，可能会出现一些对输入或者运行状态比较敏感的测试用例。这些用例难以重用，影响回归测试的效率，需要进行改进，使之可重用可控制。  


# 五 软件测试分类

## 1、黑盒测试和白盒测试
- 黑盒测试，指的是把被测的软件看作是一个黑盒子，我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。
- 白盒测试，指的是把盒子盖打开，去研究里面的源代码和程序结构。

## 2、静态测试和动态测试
- 静态测试，是指不实际运行被测软件，而只是静态地检查程序代码、界面或文档中可能存在的错误的过程。  
- 动态测试，是指实际运行被测程序，输入相应的测试数据，检查实际输出结果和预期结果是否相符的过程。  
因此，我们判断一个测试属于静态测试还是动态测试，唯一的标准就是看是否运行程序。

## 3、单元测试、集成测试、系统测试和验收测试
- 单元测试，是指对软件中的最小可测试单元进行检查和验证。
- 集成测试，是单元测试的下一个阶段，是指将通过测试的单元模块组装成系统或子系统，再进行测试，重点测试不同模块的接口部分。
- 系统测试，指的是将整个软件系统看做一个整体进行测试，包括对功能、性能，以及软件所运行的软硬件环境进行测试。  
- 验收测试，指的是在系统测试的后期，以用户测试为主，或有测试人员等质量保障人员共同参与的测试，它也是软件正式交给用户使用的最后一道工序。  
![单元集成系统验收测试比较](media/image9.png)

## 4、功能测试和性能测试
- 功能测试，是黑盒测试的一方面，它检查实际软件的功能是否符合用户的需求。功能测试又可以细分为很多种：逻辑功能测试、界面测试、易用性测试、安装测试、兼容测试等。  
- 性能测试，是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。  
软件性能测试分为一般性能测试、稳定性测试、负载测试和压力测试。  
（1）一般性能测试，指的是让被测系统在正常的软硬件环境下运行，不向其施加任何压力的性能测试。  
（2）稳定性测试，也叫可靠性测试，是指连续运行被测系统，检查系统运行时的稳定程度。我们通常用MTBF（Mean Time Between Failure，错误发生的平均时间间隔）来衡量系统的稳定性，MTBF越大，系统的稳定性越强。  
（3）负载测试，是性能测试的一种，通常是指让被测系统在其能忍受的压力的极限范围之内连续运行，来测试系统的稳定性。  
（4）压力测试，是性能测试的一种，通常是指连续不断地给被测系统增加压力，直到将被测系统压垮为止，用来测试系统所能承受的最大压力。

## 5、回归测试、冒烟测试、随机测试  
- 回归测试，是指对软件的新的版本测试时，重复执行上一个版本测试时的用例。 
- 冒烟测试，是指在对一个新版本进行系统大规模的测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。
- 随机测试，是指测试中所有的输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错误。

## 6、不同测试分类之间的关系
以上讲述了多种测试的概念，它们只是分类的角度不同而已，一种测试，按照不同的分类角度，可以属于不同的测试分类。例如，对代码的静态分析，属于静态测试，属于白盒测试，也属于单元测试。以下这张图表述了不同的测试分类及其关系。

![不同测试分类关系图](media/image1.png)


# 六 软件测试的一些基本原则  

## 1、Zero Bug与Good Enough 
  Zero Bug指的是软件没有任何Bug，Good Enough指的是只要软件达到一定的质量要求，就可以停止测试了。  
  
  对于相对复杂的产品或系统来说，没有Bug是不可能的，我们只能想方设法把软件的Bug数控制在可以忍受的范围之内。  
  
  Good Enough原则就是一种权衡投入/产出比的原则：不充分的测试是不负责任的；过分的测试是一种资源的浪费，同样也是一种不负责任的表现。我们的操作困难在于：如何界定什么样的测试是不充分的，什么样的测试是过分的。目前状况唯一可用的答案是：制定最低测试通过标准和测试内容，然后具体问题具体分析。  
  
  关于项目组如何具体制定测试的通过标准，没有统一的标准答案，可以参考下面的标准：  
  - 遗留Bug数在10个以下，其中严重的Bug在5个以下。  
  - 测试用例的执行率为100%，通过率为95%。  
  - 如果做了单元测试的话，关键模块的语句覆盖率要达到100%，分支覆盖率要达到85%。
    

## 2、不要试图穷举测试  
  穷举测试指的是测试时考虑所有可能的输入值。比如一个程序需3个整型的输入数据，若计算机的字长为32位，则每个数据可能取的值有2^32，3个数的排列组合共
  
      2^32 * 2^32 * 2^32 = 2^96（种）
      
  若每执行一次需1ms，则需2万年。  
  
  既然穷举测试不好做，我们就需要在测试用例上多下功夫，设计出优秀的测试用例，用最少的测试用例达到最大的覆盖率。

## 3、软件测试要尽早执行  
软件生命周期指的是软件开发、测试、维护的整个流程，主要包括需求阶段、设计阶段、编码阶段、单元测试阶段、验收阶段和维护阶段等。那么软件的缺陷在哪个阶段最先开始引入，哪个阶段引入的缺陷最多呢？是需求阶段，设计阶段，还是编码阶段？  

实践证明，在大多数情况下，在需求分析阶段就会产生缺陷，而且需求分析阶段引入的缺陷是最多的，其修正成本却是最低的，所以软件测试应该尽早执行，越早执行，风险越小。  

![缺陷分布图](media/image10.png)  

![缺陷修复成本图](media/image11.png) 

## 4、软件测试应该追溯需求  
  这条原则和软件测试应该尽早执行的原则贯穿整个软件生命周期，关联比较紧密，都强调了需求阶段对于软件测试的重要性。  

![缺陷产生原因图](media/image12.png)  

## 5、缺陷的二八定理  
  缺陷的二八定理，指的是一般情况下，软件80%的缺陷集中在20%的模块中。我们测试的时候要抓住主要矛盾，如果发现某一程序模块比其他模块有更多的缺陷，就要投入主要的人力和精力重点测试这20%的模块，以提高我们的测试效率。我们通常也把缺陷的二八定理称为缺陷的集群现象或是虫子窝现象。  
    
## 6、缺陷具有免疫性  
  就像一种农药使用久了，害虫会产生抗药性一样，缺陷也是具有“免疫性”的。程序员在修改完缺陷，把新版本提交给测试人员，测试人员根据相同的测试用例进行回归测试，就像是用同一种农药来杀害虫一样，其效果无疑会大打折扣，这就要求测试人员要根据新版本的特点去修改维护测试用例。  
  另外还有一个值得注意的经验，那就是每修复3~4个缺陷，一般就会产生一个新的缺陷，所以要充分注意修改错误所产生的影响和波及效果。

# 七 软件测试技术

## 1、等价类技术
等价类划分方法把所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一部分中选取少数有代表性的数据做为测试用例。  

1）等价类的定义
- 等价类：是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的。  
- 有效等价类：符合《需求规格说明书》，合理地输入数据集合。  
- 无效等价类：不符合《需求规格说明书》，无意义地输入数据集合。  

2）等价类划分的步骤  
（1）先考虑输入数据的数据类型（合法类型和非法类型）。  
（2）再考虑数据范围（合法类型中的合法区间和非法区间）。  
（3）画出示意图，区分等价类。  
（4）为每一个等价类编号。  
（5）从一个等价类中选举一个测试数据构造测试用例  

3）常用的等价类划分方法  
（1）如果输入条件规定了取值范围，或值的个数，则可以确立一个有效等价类和两个无效等价类。  
    例如，在程序的规格说明中，对输入条件有一句话：  
    “…… 数值可以从1到999 ……”   
    则有效等价类是“1≤项数≤999”  
    两个无效等价类是“项数＜1”或“项数＞999”。  
![等价类](media/image2.png)  
（2）如果输入条件规定了输入值的集合，或者是规定了“必须如何”的条件，这时可确立一个有效等价类和一个无效等价类。  
    例如，在Pascal语言中对变量标识符规定为“以字母打头的……串”。那么所有以字母打头的构成有效等价类，而不在此集合内（不以字母打头）的归于无效等价类。  
（3）如果输入条件是一个布尔量，则可以确定一个有效等价类和一个无效等价类。  
（4）如果规定了输入数据的一组值，而且程序要对每个输入值分别进行处理。这时可为每一个输入值确立一个有效等价类，此外针对这组值确立一个无效等价类，它是所有不允许的输入值的集合。
    例如，在教师上岗方案中规定对教授、副教授、讲师和助教分别计算分数，做相应的处理。因此可以确定4个有效等价类为教授、副教授、讲师和助教，一个无效等价类，它是所有不符合以上身分的人员的输入值的集合。  
（5）如果规定了输入数据必须遵守的规则，则可以确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。
    例如，Pascal语言规定 “一个语句必须以分号‘;’结束”。这时可以确定一个有效等价类 “以‘;’结束”，若干个无效等价类 “以‘:’结束”、“以‘,’结束”、“以‘ ’结束”、“以LF结束”等。  

4）用等价类划分法设计测试用例的实例  
  假设汽车的车牌号可由车主在规定范围内自选，若其规定为：  
（1）车牌上应有7个字符  
（2）为首的字符限定为汉字“京”  
（3）第2个字符可任选一字母（A-Z）  
（4）第3-7个字符可选任意数字 

为相关的处理程序采用等价类方法设计等价类表及相应的测试用例：  

等价类表（括号中数值为等价类的标识序号，共9个等价类）  
![等价类表](media/image3.png)  

则设计测试用例如下：  
![测试用例表](media/image4.png)

## 2、边界值技术  
边界值分析方法是对等价类划分方法的补充。大量的测试实践经验表明，边界值是最容易出现问题的地方，大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。针对各种边界情况设计测试用例，可以查出更多的错误。  

1）遵循的原则：  
（1）如果输入条件对取值范围进行了界定，则应以边界内部以及刚超出范围边界外的值作为测试用例。若范围的下界为x，上界为y，则测试用例应当包含x，y，以及稍小于x和稍大于y的值。  
（2）如果对取值的个数进行了界定，则应当分别以最大最小个数及稍小于最小，稍大于最大个数作为测试用例。  
（3）对于输出条件，前两条规则同样适用。  
（4）如果《程序规格说明书》中指明输入或者输出域是一个有序的集合，就应当选择集合中的第一个和最后一个元素作为测试用例。  
例如，输入规定值范围为-1~+1，则测试用例设计为：+1，-1，+1.01，-1.01  
规定输入的记录可容纳1~255条，则测试用例设计为：0,1,255,256

2）用边界值法设计测试用例的实例  
程序说明：假设有一个把数字串转换为整数的函数。其中数字串要求长度为1-6个数字构成。分析程序中出现的边界情况，采用边界值法为该程序设计测试用例。  
分析该程序的说明和功能，显然可以划分四组测试等价类：有效输入等价类、无效输入等价类、合法输出等价类和非法输出等价类。在考虑该程序的合法输出和非法输出时需要考虑计算机的字长，这时要进行边界值设计测试用例，以补充等价类法设计的测试用例。具体采用边界值法设计的测试用例如下：  
（1）使程序输入刚好等于最小的负整数：  
输入：'－32768'  
输出：－32768  
（2）使程序输入刚好等于最大的正整数：  
输入：'32767'  
输出：32767  
（3）使程序输入刚好小于最小的负整数：  
输入：'－32769'  
输出：错误  
（4）使程序输入刚好大于最大的正整数：  
输入：'32768'  
输出：错误

## 3、因果图法
前面的输入法只考虑输入条件，没有考虑输入条件的联系。因此，必须考虑一种适合于描述对于多种条件的组合，相应产生多个动作的形式来考虑设计测试用例。  
因果图法最终生成的就是判定表，适合于检查程序输入条件的各种组合情况。  
因果图是一种形式语言，用自然语言描述的规格说明可以转换为因果图。因果图实际上是一种数字逻辑电路。  

1）因果图的适用范围  
如果在测试时必须考虑输入条件的各种组合，可使用一种适合于描述对于多种条件的组合，相应产生多个动作的形式来设计测试用例，这就需要利用因果图。因果图方法最终生成的就是判定表。它适合于检查程序输入条件的各种组合情况。  

2）用因果图设计测试用例的基本步骤  
（1）分析软件规格说明描述中，哪些是原因(即输入条件或输入条件的等价类)，哪些是结果 (即输出条件)，并给每个原因和结果赋予一个标识符。  
（2）分析软件规格说明描述的语义，找出原因与结果之间，原因与原因之间对应的关系， 根据这些关系，画出因果图。  
（3）由于语法或环境限制，有些原因与原因之间，原因与结果之间的组合情况不可能出现。为表明这些特殊情况，在因果图上用一些记号标明约束或限制条件。  
（4）把因果图转换成判定表。  
（5）把判定表的每一列拿出来作为依据，设计测试用例。  

3）因果图中使用的符号  

通常在因果图中用Ci表示原因，用Ei表示结果，各结点表示状态，可取值 “0”或“1”。“0”表示某状态不出现，“1”表示某状态出现。若有多个状态，可取大于1的多个值表示。

主要的原因和结果之间的关系有:  
![原因结果关系图](media/image5.png)  
- 恒等：若原因出现，则结果出现；若原因不出现，则结果也不出现。  
- 非（~）：若原因出现，则结果不出现；若原因不出现，则结果出现。  
- 或（V）：若几个原因中的一个出现，则结果出现；若原因都没出现，则结果不出现。  
- 与（^）：若几个原因出现，结果才出现。  

表示约束条件的符号  
为了表示原因与原因之间，结果与结果之间可能存在的约束条件，在因果图中可以附加一些表示约束条件的符号。  
![约束条件符号](media/image6.png)  
- E（互斥）：a，b两个原因不能同时成立，两个中最多只能一个成立。  
- I（包含）：表示a，b，c三个原因中至少有一个必须成立。  
- O（唯一）：表示a和b当中必须有且只有一个成立。  
- R（要求）：表示当a出现的时候，b也必须出现。  
- M（屏蔽）：表示当a是I时，b必须是O。而当a为O时，b的值不定。  

4）用因果图法设计测试用例的实例  
有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：  
若投入5角钱或1元钱的硬币，押下〖橙汁〗或〖啤酒〗的按钮，则相应的饮料就送出来；若售货机没有零钱找，则一个显示〖零钱找完〗的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示〖零钱找完〗的红灯灭，在送出饮料的同时退还5角硬币。 

1> 分析这一段说明，列出原因和结果  
原因:   
（1）售货机有零钱找  
（2）投入1元硬币  
（3）投入5角硬币  
（4）押下橙汁按钮  
（5）押下啤酒按钮
	
建立中间结点，表示处理中间状态  
（11）投入1元硬币且押下饮料按钮  
（12）押下〖橙汁〗或〖啤酒〗的按钮  
（13）应当找5角零钱并且售货机有零钱找  
（14）钱已付清

结果：  
（21）售货机〖零钱找完〗灯亮  
（22）退还1元硬币  
（23）退还5角硬币  
（24）送出橙汁饮料  
（25）送出啤酒饮料  

2> 画出因果图。所有原因结点列在左边，所有结果结点列在右边。 

3> 由于 2 与 3 ，4 与 5 不能同时发生，分别加上约束条件E。 

4> 因果图

5> 转换成判定表  

因果图：  
![因果图](media/image7.png)  

判定表：  
![判定表](media/image8.png)

## 4、流程图法  
1）流程图的适用范围  
我们在编程的时候，一般都需要画程序的算法流程图。我们可以将这一思想应用到黑盒测试领域。算法流程图是针对程序内部结构的，而黑盒测试的流程图是针对整个系统业务功能流程的。  
例如，我们测试一个B-C（商家对顾客）的电子商务网站，可以画一个顾客购物的流程图；我们要测试某个机票预订系统，可以画一个订票的流程图。
凡事涉及业务流程的地方，我们都可以应用这种方法，甚至是在安装的过程中也可以应用。  

2）流程图法的步骤  
- 第一步：详细了解需求。  
- 第二步：根据需求说明或界面原型，找出业务流程的各个页面及各页面之间的流转关系。  
- 第三步：画出业务流图（路径图）。  
- 第四步：写用例，覆盖所有的路径分支。  

3）流程图实例  
算法流程图  
![算法流程图](media/image13.png)  

订票模块业务流程图  
![订票模块业务流程图](media/image14.png)  

4）流程图法的特点与优势  
流程图法一般不是针对具体某个页面或是某个模块的测试，而是将被测系统看作一个完整的系统，从宏观上来分析其业务流程，然后再画出流程图来。其好处在于能够使测试人员对被测系统有一个总体的把握，防止测试的时候有遗漏的页面或模块。


# 八 缺陷管理

## 1、Bug的分类  
从不同的分类角度，我们可以将Bug分为多种类型。  
1）按严重程度（Severity）划分  
是指Bug对软件质量的破坏程度，即此Bug的存在将对软件的功能和性能产生怎样的影响，按照严重程度由高到低的顺序可以分成5个等级：系统崩溃、严重、一般、次要、建议。  
需要说明的是，在具体的项目中，要根据实际情况来划分等级，不一定是5个等级。如果Bug数比较少，就可以划分为3个等级：严重、一般、次要。一般的缺陷管理工具会自动给出一个默认的Bug严重程度划分。  

2）按优先级（Priority）划分  
表示处理和修正软件缺陷的先后顺序饿指标，即哪些缺陷需要优先修正，哪些缺陷可以稍后修正，按照优先级由高到低可以分成3个等级：高（High）、中（Middle）、低（Low）。其中高优先级的Bug是应该立即修复的Bug，中优先级的Bug是应该在产品发布之前修复的Bug，低优先级的Bug是指如果时间允许应该修复的Bug或是可以暂时存在的Bug。和Bug的严重程度一样，优先级的这种分法也不是绝对的，需要我们根据实际情况灵活划分。  

3）按照测试种类划分  
可以将Bug分为逻辑功能类（Function）、性能类（Performance）、界面类（UI）、易用性类（Usability）、兼容性类（Compatibility）。  

4）按功能模块划分  
一般的软件产品都是分为若干个功能模块的，比如Word 2000里面可以分为文件、编辑、视图……帮助等功能模块，二八定理告诉我们，80%的缺陷大部分集中在20%的模块里面，测试的时候我们可以统计一下Bug主要集中在哪些模块里面，以便我们投入重点精力去测试。  
我们可以把3和4两种分类方法合到一起：把功能模块类都作为逻辑功能类，比如我们测试Word 2000时可以对Bug这样分类：文件、编辑、视图……帮助，性能类、界面类、易用性类、兼容性类。  

5）按Bug生命周期划分  
我们可以把Bug看作一个有生命的小虫子，每一个Bug都有其生存和死亡的生命周期，可以这样划分：新建（New）、确认（Confirmed）、解决（Fixed）、关闭（Closed）、重新打开（Reopen）。  
一个Bug由测试人员发现并提交，我们将状态标注为新建；开发人员接收了该Bug，将Bug的状态修改为已分配（Assigned），表示已经认可；开发人员解决了该Bug后，就将Bug的状态修改为解决，并发给测试人员回归测试；测试人员对Bug进行回归测试，如果确实已经解决，就将Bug的状态修改为关闭，否则的话则发给开发人员重新修改。还要说明的是，Bug是可以“死而复生”的，以前版本已经关闭的Bug，如果新版本中重新出现，我们就需要将其状态修改为重新打开。  

## 2、缺陷报告  
在实际项目中，我们提交Bug时需要根据固定的模板，这个模板可以是Word、Excel或是缺陷管理工具自带的模板，其基本形式如下图所示。  
![缺陷报告](media/image15.png)

## 3、Bug的处理流程  
大多数情况下，缺陷报告的处理只经过“提交-分配-解决-关闭”这样一个比较简单的流程，但是在有些情况下，这个过程会变得比较复杂，例如，开发组可能认为此问题不是Bug，因此处理意见一栏中填入“不是问题”，将Bug返给测试人员，这样就需要由测试人员、开发人员甚至是项目经理共同来讨论其到底是不是Bug，这种关于缺陷是否修改的讨论过程有时会反复多次。因此，我们应该对处理流程进行完善。  
我们通过流程图给大家展示一个比较完善的Bug处理流程。  
![Bug处理流程](media/image16.png)


# 九 测试管理

## 1、软件的生命周期  
1）什么是软件的生命周期
软件的生命周期是软件工程中非常重要的概念，也是我们学习项目管理流程的一个基础知识。其基本定义为：软件生命周期，是指软件开发和测试全部过程、活动和任务的结构框架，是从可行性研究到需求分析、软件设计、编码、测试、软件发布维护的过程。  

2）软件开发的生命周期  
软件开发的生命周期，也叫软件开发的流程，是指软件的开发过程中需要经过哪些环节。  
软件开发的基本环节包括：需求分析、概要设计、详细设计、编码、维护。  

3）软件测试的生命周期  
软件测试的生命周期基本环节包括：测试计划、测试设计、测试执行、测试评估。  

4）软件生命周期的模型  
（1）瀑布模型  
瀑布模型是早期经典的软件生命周期模型。之所以叫做瀑布模型，是因为每一个阶段划分的比较清晰，逐层向下，具有和瀑布类似的特点。  
瀑布模型的优点：  
- 开发的各个阶段比较清晰。  
- 强调早期计划及需求调查。  
- 适合需求稳定的产品开发。  
瀑布模型的缺点：  
- 依赖于早期的需求调查，不适应需求的变化。  
- 单一流程，不可逆。  
- 风险往往迟至后期才显露，失去及早纠正的机会。  
- 测试仅是编码后的一个阶段。  

现在的软件项目大部分需求都不稳定，往往需要反复的确认和验证，因此瀑布模型不适合需求经常变化的项目。另外，在瀑布模型中，测试仅仅是编码后的一个阶段，与实际情况不符。  
![瀑布模型](media/image17.png)

（2）螺旋模型  
螺旋模型是在瀑布模型的基础上提出来的。之所以叫做螺旋模型，是因为这是一个迭代开发的过程，每一迭代过程均由需求、设计、编码、测试、集成等阶段组成。实际上，这个模型可看作是重复执行的多个“瀑布模型”，并在“瀑布模型”的每一个开发阶段之前，引入非常严格的风险控制。直到采取了消除风险的措施之后，才开始计划下一阶段的开发工作。  
螺旋模型比较适合需求经常变化的软件项目，但是开发过程比较复杂，如果控制不好容易造成流程混乱。  
![螺旋模型](media/image18.png)  

（3）V模型  
V模型属于比较新的模型。之所以叫做V模型，是因为其形状看起来像个V字。其实如果我们把编码后面的4个阶段向下翻转，它就又变成了瀑布模型。  
V模型的优点就是详细表示了测试的各个阶段以及参考依据：  
- 单元测试参考的是《详细设计》。  
- 集成测试参考的是《概要设计》。  
- 系统测试参考的是《需求规格说明书》。  
- 验收测试参考的是实际用户需求。  

V模型的缺点是没有说明在项目的前期测试需要做哪些工作（编写测试计划、测试用例等），而且和瀑布模型一样，流程也是单项的，不可逆。  
![V模型](media/image19.png)  

（4）W模型  
W模型是在V模型基础上发展起来的，也是目前测试领域的主流测试模型。  
相比于V模型，W模型增加了软件各开发阶段中应同步进行的验证和确认活动。W模型由两个V模型组成，分别代表测试与开发过程，图中明确表示出了测试与开发的并行关系。  
W模型强调：测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试，也就是说，测试与开发是同步进行的。  
W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和测试风险，及早制定对应措施，这将显著减少总体测试时间，加快项目进度。  
但W模型也存在局限性。在W模型中，需求、设计、编码等活动被视为串行的，同时，测试和开发活动也保持着一种线性的前后关系，上一阶段完全接受，才可正式开始下一阶段工作。这样就无法支持迭代的开发模型。对于当前软件开发复杂多变的情况，W模型并不能解除测试管理面临着困惑。  
![W模型](media/image20.png)  

## 2、软件测试评估  
软件测试评估，也就是测试总结，是软件测试生命周期的最后一个环节。在这一环节里面，测试主管需要对测试的过程和结果都有一个系统的评价，并需要判定软件产品能否最终发布或是交给用户进行验收，这就要求测试主管具备一定的分析和归纳能力。  
测试评估主要分成两种，对覆盖的评测（也叫做对测试过程的评测）和对缺陷的评测（也叫做对测试结果的评测）。  

1）对覆盖的评测  
对覆盖的评测，关注的是软件测试的过程，它又分成两种覆盖：对源代码的覆盖和对需求的覆盖。  
（1）对源代码的覆盖  
是指在单元测试过程，所测试到的源代码占代码总数的百分比，一般有语句覆盖、分支覆盖、条件覆盖、路径覆盖等方法。一个通用的代码覆盖标准是，对软件关键模块的语句覆盖率要达到100%，分支覆盖率要达到85%以上。  
（2）对需求的覆盖  
是指在系统测试过程中，所测试到的功能和非功能需求占到需求总数的百分比。一般我们可以通过测试用例的执行率来衡量，一个通用的需求覆盖标准是，测试用例的执行率要在100%，即所有的用例都要执行一遍，测试用例的通过率要达到95%以上。  

2）对缺陷的评测  
对缺陷的评测，也称之为对结果的评测，是通过分析和统计缺陷情况来对测试结果给出一个综合的评定，它的直接表现形式就是各种缺陷统计图表。  
（1）缺陷分布图  
缺陷分布图用来统计各种缺陷的分布情况，我们可以按照缺陷的各种分类来统计，比如按照缺陷所在的模块来统计，按照缺陷的严重程度来统计，按照缺陷的优先级来统计，按照缺陷的生命周期来统计等，很多缺陷管理工具都具有缺陷分类统计的功能。  
（2）缺陷趋势图  
除了缺陷分布图之外，还有一种常用的缺陷统计图——缺陷趋势图。该图是用来描述缺陷的变化趋势的。  
横坐标一般为时间或是测试的轮数，纵坐标为系统遗留缺陷数目。从缺陷趋势图中，我们可以直观地查看缺陷数量的变化情况，为我们什么时候停止测试提供数据支持。  

## 3、软件测试报告  
在测试评估的基础上，我们就可以撰写测试总结报告，测试总结一般需要包括的内容有：测试项目概述、测试机构和人员、测试用例统计结果、缺陷分类统计结果，以及测试结论等。  
某管理系统测试总结举例  
![测试总结](media/image22.png) 


# 参考文献

1.《软件测试》  
作者：(美) Ron Patton
译者：周予滨  姚静
出版社：机械工业出版社  

2.《软件测试技术经典教程》  
作者：赵斌
出版社：科学出版社  

3.《软件测试理论与实践》  
作者：毛志雄
出版社：中国铁道出版社

4.《软件测试的艺术 第3版》  
作者：(美) Glenford J Myers
译者：张晓明 黄琳
出版社：机械工业出版社
